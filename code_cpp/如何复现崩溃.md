# 如何复现崩溃 - 完整指南

## 一、检查是否发现崩溃

### 1.1 查看崩溃文件

```bash
cd ~/软工/code_cpp

# 查看崩溃目录
ls -lh fuzz_output/default/crashes/

# 如果目录存在且有文件，说明发现了崩溃
# 如果目录不存在或为空，说明未发现崩溃
```

### 1.2 查看AFL++统计信息

```bash
# 查看统计信息
cat fuzz_output/default/fuzzer_stats | grep "unique_crashes"

# 如果 unique_crashes > 0，说明发现了崩溃
```

---

## 二、复现崩溃的方法

### 方法1: 直接使用崩溃文件（最简单）

```bash
cd ~/软工/code_cpp

# 查看崩溃文件列表
ls fuzz_output/default/crashes/

# 使用第一个崩溃文件复现
./fuzz_bin/fuzz_target < fuzz_output/default/crashes/id:000000*

# 或者指定具体文件
./fuzz_bin/fuzz_target < fuzz_output/default/crashes/id:000000,sig:11,src:000000,op:flip1,pos:0
```

**预期输出**: 程序会崩溃，显示段错误（Segmentation fault）或其他错误信息

**截图**: 显示崩溃命令和崩溃输出

---

### 方法2: 查看崩溃文件内容

```bash
# 查看崩溃文件内容
cat fuzz_output/default/crashes/id:000000*

# 或者使用hexdump查看二进制内容
hexdump -C fuzz_output/default/crashes/id:000000* | head -20
```

**截图**: 显示崩溃文件的内容

---

### 方法3: 使用调试器分析（推荐，最详细）

#### 使用GDB调试

```bash
cd ~/软工/code_cpp

# 启动gdb
gdb ./fuzz_bin/fuzz_target

# 在gdb中运行崩溃文件
(gdb) run < fuzz_output/default/crashes/id:000000*

# 程序崩溃后，查看堆栈
(gdb) bt

# 查看崩溃位置的代码
(gdb) list

# 查看寄存器
(gdb) info registers

# 查看变量值
(gdb) print variable_name

# 退出gdb
(gdb) quit
```

**截图**: 
- gdb运行命令
- 崩溃堆栈信息（bt输出）
- 崩溃位置的代码

---

### 方法4: 使用AddressSanitizer编译（最详细的分析）

#### 使用ASan重新编译

```bash
cd ~/软工/code_cpp

# 使用afl-clang++和ASan编译
afl-clang++ -fsanitize=address -g -std=c++17 -I./src \
    -o fuzz_bin/fuzz_target_asan \
    fuzz_test_target.cpp \
    src/Category.cpp src/MainUI.cpp src/Record.cpp src/Search.cpp \
    src/Statistics.cpp src/Storage.cpp src/User.cpp

# 使用ASan版本复现崩溃
./fuzz_bin/fuzz_target_asan < fuzz_output/default/crashes/id:000000*
```

**预期输出**: ASan会显示详细的错误信息，包括：
- 错误类型（如缓冲区溢出）
- 错误位置（文件名和行号）
- 内存地址信息
- 堆栈跟踪

**截图**: 显示ASan的详细错误报告

---

## 三、详细复现步骤

### 步骤1: 确认崩溃文件

```bash
cd ~/软工/code_cpp

# 列出所有崩溃文件
ls -lh fuzz_output/default/crashes/

# 查看崩溃文件数量
echo "崩溃文件数量: $(ls fuzz_output/default/crashes/ 2>/dev/null | wc -l)"
```

**截图**: 显示崩溃文件列表

---

### 步骤2: 查看崩溃文件内容

```bash
# 查看第一个崩溃文件的内容
cat fuzz_output/default/crashes/id:000000* | head -1

# 或者查看所有崩溃文件
for crash in fuzz_output/default/crashes/id:*; do
    echo "=== $crash ==="
    cat "$crash"
    echo ""
done
```

**截图**: 显示崩溃文件的内容

---

### 步骤3: 复现崩溃（基本方法）

```bash
# 使用崩溃文件作为输入
./fuzz_bin/fuzz_target < fuzz_output/default/crashes/id:000000*
```

**预期输出示例**:
```
Segmentation fault (core dumped)
```

或

```
段错误 (核心已转储)
```

**截图**: 显示崩溃命令和崩溃输出

---

### 步骤4: 使用GDB详细分析

```bash
# 启动gdb
gdb ./fuzz_bin/fuzz_target

# 在gdb中运行
(gdb) run < fuzz_output/default/crashes/id:000000*

# 程序崩溃后
(gdb) bt
# 输出堆栈跟踪

(gdb) info registers
# 输出寄存器信息

(gdb) list
# 显示崩溃位置的代码
```

**截图**: 
- gdb命令和输出
- 堆栈跟踪（bt）
- 崩溃位置的代码

---

### 步骤5: 使用ASan获取详细信息

```bash
# 编译ASan版本
afl-clang++ -fsanitize=address -g -std=c++17 -I./src \
    -o fuzz_bin/fuzz_target_asan \
    fuzz_test_target.cpp src/*.cpp

# 运行ASan版本
./fuzz_bin/fuzz_target_asan < fuzz_output/default/crashes/id:000000*
```

**预期输出示例**:
```
=================================================================
==12345==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff12345678
    #0 0x... in Storage::copyCategoryName ...
    #1 0x... in main ...
    ...
==12345==ABORTING
```

**截图**: 显示ASan的详细错误报告

---

## 四、崩溃分析

### 4.1 分析崩溃类型

根据崩溃信息判断：
- **段错误 (SIGSEGV)**: 通常是缓冲区溢出、空指针解引用
- **总线错误 (SIGBUS)**: 通常是内存对齐问题
- **ASan报告**: 会明确指出错误类型和位置

### 4.2 分析崩溃位置

从堆栈跟踪或ASan报告中找到：
- **崩溃函数**: 通常是 `Storage::copyCategoryName`
- **崩溃行号**: 通常是 `Storage.cpp:125`（strcpy调用）
- **崩溃原因**: 缓冲区溢出（类别名超过64字符）

### 4.3 分析触发条件

从崩溃文件内容分析：
- **输入格式**: TSV格式
- **关键字段**: 类别字段（第5个字段）
- **触发条件**: 类别名长度 >= 64字符

---

## 五、截图清单

为了实验报告，需要以下截图：

1. ✅ **崩溃文件列表**
   ```bash
   ls -lh fuzz_output/default/crashes/
   ```

2. ✅ **崩溃文件内容**
   ```bash
   cat fuzz_output/default/crashes/id:000000*
   ```

3. ✅ **基本复现**
   ```bash
   ./fuzz_bin/fuzz_target < fuzz_output/default/crashes/id:000000*
   ```
   显示崩溃输出（段错误）

4. ✅ **GDB分析**（可选但推荐）
   - gdb运行命令
   - 堆栈跟踪（bt）
   - 崩溃位置代码

5. ✅ **ASan分析**（推荐）
   - ASan编译命令
   - ASan错误报告（显示缓冲区溢出位置）

---

## 六、完整复现示例

### 示例1: 基本复现

```bash
cd ~/软工/code_cpp

# 1. 查看崩溃文件
ls fuzz_output/default/crashes/

# 2. 查看崩溃内容
cat fuzz_output/default/crashes/id:000000*

# 3. 复现崩溃
./fuzz_bin/fuzz_target < fuzz_output/default/crashes/id:000000*

# 输出: Segmentation fault
```

### 示例2: 使用GDB分析

```bash
cd ~/软工/code_cpp

gdb ./fuzz_bin/fuzz_target
(gdb) run < fuzz_output/default/crashes/id:000000*
(gdb) bt
(gdb) list
(gdb) quit
```

### 示例3: 使用ASan分析

```bash
cd ~/软工/code_cpp

# 编译ASan版本
afl-clang++ -fsanitize=address -g -std=c++17 -I./src \
    -o fuzz_bin/fuzz_target_asan \
    fuzz_test_target.cpp src/*.cpp

# 运行
./fuzz_bin/fuzz_target_asan < fuzz_output/default/crashes/id:000000*
```

---

## 七、如果未发现崩溃

如果运行5小时后仍未发现崩溃：

### 查看运行时间

```bash
# 查看统计信息
cat fuzz_output/default/fuzzer_stats

# 查看运行时间
grep "run_time" fuzz_output/default/fuzzer_stats
```

### 截图证明

1. AFL++运行界面（显示运行时间至少5小时）
2. `fuzzer_stats`文件内容
3. 说明已运行足够长时间但未发现崩溃

---

现在你可以按照上述步骤复现崩溃了！如果遇到问题，请告诉我。

