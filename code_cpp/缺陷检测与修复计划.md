# 缺陷检测与修复计划

本文档记录了代码中的缺陷，以及如何检测和修复它们。

## 缺陷列表（待检测和修复）

### 缺陷1: 内存泄漏 (Memory Leak)
- **位置**: `src/Storage.cpp:69`
- **函数**: `Storage::loadRecords()`
- **问题描述**: 分配了1024字节的缓冲区但从未使用或释放，导致内存泄漏
- **检测方法**: 
  - 使用Valgrind: `valgrind --leak-check=full ./bin/test_defects.exe --gtest_filter=DefectDetection.MemoryLeakInLoadRecords`
  - 使用AddressSanitizer编译并运行测试
- **测试用例**: `test_defects.cpp::MemoryLeakInLoadRecords`

### 缺陷2: 缓冲区溢出 (Buffer Overflow)
- **位置**: `src/Storage.cpp:125`
- **函数**: `Storage::copyCategoryName()`
- **问题描述**: 使用`strcpy`将字符串复制到固定大小的缓冲区，如果源字符串长度>=64会导致缓冲区溢出
- **检测方法**:
  - 使用AddressSanitizer: 编译时添加`-fsanitize=address`，运行测试时会报告缓冲区溢出
  - 传入超长字符串（100个字符）触发溢出
- **测试用例**: `test_defects.cpp::BufferOverflowInCopyCategoryName`

### 缺陷3: 双重释放 (Double Free)
- **位置**: `src/Search.cpp:77`
- **函数**: `Search::processSearchResults()`
- **问题描述**: 对同一个指针调用`delete`两次，导致未定义行为
- **检测方法**:
  - 使用AddressSanitizer: 会报告"double-free"错误
  - 使用Valgrind: 会报告"Invalid free()"错误
- **测试用例**: `test_defects.cpp::DoubleFreeInProcessSearchResults`

### 缺陷4: NULL指针解引用 (NULL Pointer Dereference)
- **位置**: `src/Statistics.cpp:118`
- **函数**: `Statistics::formatSummaryData()`
- **问题描述**: 在指针可能为NULL的情况下直接解引用，当`summary.count <= 1000`时会崩溃
- **检测方法**:
  - 使用AddressSanitizer: 会报告"null-pointer-dereference"错误
  - 程序可能直接崩溃（段错误）
- **测试用例**: `test_defects.cpp::NullPointerDereferenceInFormatSummaryData`

## 检测步骤

### 步骤1: 使用AddressSanitizer检测

```bash
# 1. 修改Makefile，在CXXFLAGS中添加ASan选项
# 或者直接编译：
g++ -std=c++17 -fsanitize=address -g -I./src -I./tests \
    -I/usr/local/include -o bin/test_defects_asan.exe \
    tests/test_defects.cpp src/*.cpp -lgtest -lgtest_main -lpthread

# 2. 运行测试
./bin/test_defects_asan.exe

# 3. 查看ASan报告的错误信息
```

### 步骤2: 使用Valgrind检测（Linux）

```bash
# 检测内存泄漏
valgrind --leak-check=full --show-leak-kinds=all \
    ./bin/test_defects.exe --gtest_filter=DefectDetection.MemoryLeakInLoadRecords

# 检测双重释放
valgrind --leak-check=full \
    ./bin/test_defects.exe --gtest_filter=DefectDetection.DoubleFreeInProcessSearchResults
```

### 步骤3: 使用静态分析工具

```bash
# 使用CppCheck
cppcheck --enable=all src/

# 查看报告
cat cppcheck_report.xml
```

## 修复计划

检测到缺陷后，将按照以下步骤修复：

1. **记录缺陷信息**: 截图保存检测工具的报告
2. **分析缺陷原因**: 理解缺陷的根本原因
3. **设计修复方案**: 使用AI助手（Cursor）获取修复建议
4. **实施修复**: 修改代码
5. **验证修复**: 重新运行测试，确认缺陷已修复

## 修复后的验证

修复后，应该：
1. 重新运行缺陷检测测试，确认不再报告错误
2. 运行所有单元测试，确认功能正常
3. 使用检测工具再次验证，确认缺陷已消除

## 截图清单

为了实验报告，需要截图：

1. ✅ **缺陷检测前**: 运行测试，显示缺陷存在
2. ✅ **检测工具报告**: ASan/Valgrind/CppCheck的错误报告
3. ✅ **AI辅助分析**: 在Cursor中询问AI如何修复缺陷
4. ✅ **修复过程**: 修复代码的过程
5. ✅ **修复后验证**: 重新运行测试，确认缺陷已修复

## 注意事项

- 缺陷代码已恢复，可以正常检测
- 某些缺陷可能导致程序崩溃，这是正常的
- 建议在Linux环境或WSL中进行检测
- 修复缺陷后，需要更新`缺陷修复记录.md`文档

