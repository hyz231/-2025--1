# 缺陷检测说明

本文档说明如何检测代码中的缺陷，以便在实验报告中展示测试发现问题的过程。

## 缺陷列表

代码中包含了以下缺陷（已恢复，未修复）：

1. **内存泄漏** - `Storage::loadRecords()` (第69行)
2. **缓冲区溢出** - `Storage::copyCategoryName()` (第125行)
3. **双重释放** - `Search::processSearchResults()` (第77行)
4. **NULL指针解引用** - `Statistics::formatSummaryData()` (第118行)

## 检测方法

### 方法1: 使用AddressSanitizer (推荐)

AddressSanitizer (ASan) 可以检测多种内存错误，包括：
- 缓冲区溢出
- 双重释放
- 使用已释放的内存
- NULL指针解引用

#### 编译带ASan的测试程序

```bash
# 修改Makefile，添加ASan选项
# 在CXXFLAGS中添加: -fsanitize=address -g

# 或者直接编译
g++ -std=c++17 -fsanitize=address -g -I./src -I./tests \
    -I/usr/local/include -o bin/test_defects_asan.exe \
    tests/test_defects.cpp src/*.cpp -lgtest -lgtest_main -lpthread

# 运行测试
./bin/test_defects_asan.exe
```

#### 预期输出

ASan会在发现缺陷时输出详细的错误信息，包括：
- 错误类型
- 发生位置（文件名和行号）
- 内存地址
- 调用栈

**示例输出**:
```
=================================================================
==12345==ERROR: AddressSanitizer: heap-use-after-free on address 0x...
    #0 0x... in Search::processSearchResults ...
    #1 0x... in DefectDetection_DoubleFreeInProcessSearchResults_Test::TestBody() ...
```

### 方法2: 使用Valgrind (Linux)

Valgrind可以检测内存泄漏和内存错误。

#### 安装Valgrind

```bash
sudo apt-get install valgrind
```

#### 运行测试

```bash
# 检测内存泄漏
valgrind --leak-check=full --show-leak-kinds=all \
    ./bin/test_defects.exe --gtest_filter=DefectDetection.MemoryLeakInLoadRecords

# 检测双重释放
valgrind --leak-check=full \
    ./bin/test_defects.exe --gtest_filter=DefectDetection.DoubleFreeInProcessSearchResults
```

#### 预期输出

Valgrind会输出详细的内存错误报告：

**内存泄漏示例**:
```
==12345== 1,024 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x...: operator new[](unsigned long)
==12345==    by 0x...: Storage::loadRecords() (Storage.cpp:69)
```

**双重释放示例**:
```
==12345== Invalid free() / delete / delete[] / realloc()
==12345==    at 0x...: operator delete(void*)
==12345==    by 0x...: Search::processSearchResults (Search.cpp:77)
```

### 方法3: 使用静态分析工具

#### CppCheck

```bash
# 安装cppcheck
sudo apt-get install cppcheck

# 运行检查
cppcheck --enable=all --xml --xml-version=2 src/ 2> cppcheck_report.xml
```

#### 预期发现

CppCheck可以发现：
- 内存泄漏（如果配置正确）
- 缓冲区溢出（部分情况）
- NULL指针解引用

### 方法4: 运行时崩溃测试

某些缺陷（如NULL指针解引用、双重释放）可能导致程序崩溃。

#### 使用GTest的死亡测试

```cpp
EXPECT_DEATH({
    // 触发缺陷的代码
}, ".*");
```

#### 运行测试

```bash
./bin/test_defects.exe --gtest_filter=DefectDetection.*
```

## 测试用例说明

### test_defects.cpp

包含了专门用于检测缺陷的测试用例：

1. **MemoryLeakInLoadRecords**: 检测内存泄漏
   - 多次调用`loadRecords()`，观察内存使用
   - 需要使用Valgrind或ASan来检测

2. **BufferOverflowInCopyCategoryName**: 检测缓冲区溢出
   - 传入超长字符串（100个字符）
   - 使用ASan可以检测到

3. **DoubleFreeInProcessSearchResults**: 检测双重释放
   - 调用`processSearchResults()`
   - 使用ASan或Valgrind可以检测到

4. **NullPointerDereferenceInFormatSummaryData**: 检测NULL指针解引用
   - 传入`count <= 1000`的summary
   - 使用ASan可以检测到，或程序可能崩溃

## 截图建议

为了实验报告，建议截图以下内容：

1. **编译带ASan的测试程序**
   - 显示编译命令和成功编译的输出

2. **运行缺陷检测测试**
   - 显示ASan或Valgrind的错误报告
   - 突出显示错误类型和位置

3. **CppCheck静态分析结果**
   - 显示检测到的缺陷列表

4. **程序崩溃截图**（如果有）
   - 显示程序因缺陷而崩溃的情况

5. **修复前后的对比**
   - 修复前：测试发现缺陷
   - 修复后：测试通过

## 注意事项

1. **ASan在Windows上的支持**: 
   - Windows上可以使用MSVC的AddressSanitizer
   - 或者使用WSL运行Linux版本的测试

2. **Valgrind仅支持Linux**:
   - Windows上无法使用Valgrind
   - 建议使用WSL或Linux虚拟机

3. **某些缺陷可能不会立即崩溃**:
   - 内存泄漏不会导致崩溃，但会逐渐消耗内存
   - 需要使用专门工具检测

4. **测试环境**:
   - 建议在Linux环境下进行缺陷检测
   - Windows可以使用WSL或虚拟机

## 快速开始

```bash
# 1. 编译测试程序（带ASan）
cd code_cpp
make clean
# 修改Makefile添加 -fsanitize=address -g 到CXXFLAGS
make test-defects

# 2. 运行缺陷检测测试
./bin/test_defects.exe

# 3. 使用Valgrind（Linux）
valgrind --leak-check=full ./bin/test_defects.exe

# 4. 使用CppCheck
cppcheck --enable=all src/
```

