# 植入代码缺陷记录

本文档记录了在项目中植入的代码缺陷，用于测试静态分析工具、大语言模型和形式化工具的检测能力。

---

## 缺陷列表

### 缺陷 #1: Memory Leak (内存泄漏)

- **类型**: Memory Leak
- **CWE**: CWE-401 (Missing Release of Memory after Effective Lifetime)
- **文件**: `code_cpp/src/Storage.cpp`
- **行号**: 67-68, 78
- **函数**: `Storage::loadRecords()`
- **描述**: 在函数中分配了1024字节的缓冲区，但在函数返回前从未释放，导致内存泄漏。

**代码片段**:
```cpp
// [IMPLANTED FLAW #1: Memory Leak]
// Allocated buffer but never freed - memory leak
char* buffer = new char[1024];
std::string line;
while (std::getline(ifs, line)) {
    // ... processing ...
}
// Memory leak: buffer is never deleted
return out;
```

**触发条件**: 每次调用 `Storage::loadRecords()` 时都会泄漏1024字节内存。

---

### 缺陷 #2: Double Free (重复释放)

- **类型**: Double Free
- **CWE**: CWE-415 (Double Free)
- **文件**: `code_cpp/src/Search.cpp`
- **行号**: 62-75
- **函数**: `Search::processSearchResults()`
- **描述**: 在函数中分配了一个整数指针，释放后再次尝试释放同一个指针，导致双重释放漏洞。

**代码片段**:
```cpp
// [IMPLANTED FLAW #2: Double Free]
// Helper function that demonstrates double free vulnerability
void Search::processSearchResults(const std::vector<Record> &records) {
    if (records.empty()) {
        return;
    }
    // Allocate memory for processing
    int* resultCount = new int(static_cast<int>(records.size()));
    
    // Some processing...
    (void)resultCount;
    
    // First free
    delete resultCount;
    
    // [IMPLANTED FLAW: Double Free]
    // Attempting to free the same pointer twice
    delete resultCount;  // Double free - resultCount was already deleted above
}
```

**触发条件**: 调用 `Search::processSearchResults()` 时会触发双重释放。

---

### 缺陷 #3: NULL Pointer Dereference (空指针解引用)

- **类型**: NULL Pointer Dereference
- **CWE**: CWE-476 (NULL Pointer Dereference)
- **文件**: `code_cpp/src/Statistics.cpp`
- **行号**: 103-120
- **函数**: `Statistics::formatSummaryData()`
- **描述**: 在函数中，当 `summary.count <= 1000` 时，`summaryBuffer` 保持为 `nullptr`，但后续代码直接使用该指针而不检查是否为 NULL，导致空指针解引用。

**代码片段**:
```cpp
// [IMPLANTED FLAW #3: NULL Pointer Dereference]
// Function that dereferences a pointer without checking for NULL
void Statistics::formatSummaryData(const TimeSummary &summary) {
    // Allocate a buffer that might fail
    char* summaryBuffer = nullptr;
    
    // In some error condition, buffer might remain NULL
    if (summary.count > 1000) {
        summaryBuffer = new char[256];
        std::strcpy(summaryBuffer, "Large dataset");
    }
    
    // [IMPLANTED FLAW: NULL Pointer Dereference]
    // Using pointer without checking if it's NULL first
    // This will crash if summary.count <= 1000
    std::cout << "Formatted: " << summaryBuffer << std::endl;
    
    if (summaryBuffer != nullptr) {
        delete[] summaryBuffer;
    }
}
```

**触发条件**: 当调用 `Statistics::formatSummaryData()` 且传入的 `summary.count <= 1000` 时，会触发空指针解引用。

---

### 缺陷 #4: Use After Free (释放后使用)

- **类型**: Use After Free
- **CWE**: CWE-416 (Use After Free)
- **文件**: `code_cpp/src/User.cpp`
- **行号**: 106-122
- **函数**: `User::processUserData()`
- **描述**: 在函数中分配了一个整数数组，释放后仍然尝试使用该指针访问内存，导致释放后使用漏洞。

**代码片段**:
```cpp
// [IMPLANTED FLAW #4: Use After Free]
// Function that uses a pointer after it has been freed
void User::processUserData() {
    // Allocate memory for user data processing
    int* userData = new int[100];
    for (int i = 0; i < 100; ++i) {
        userData[i] = i;
    }
    
    // Free the memory
    delete[] userData;
    
    // [IMPLANTED FLAW: Use After Free]
    // Attempting to use the pointer after it has been freed
    // This will cause undefined behavior
    int value = userData[10];  // Use after free - userData was already deleted
    (void)value;
}
```

**触发条件**: 调用 `User::processUserData()` 时会触发释放后使用。

---

### 缺陷 #5: Buffer Overflow (缓冲区溢出)

- **类型**: Buffer Overflow
- **CWE**: CWE-120 (Classic Buffer Overflow)
- **文件**: `code_cpp/src/Storage.cpp`
- **行号**: 116-128
- **函数**: `Storage::copyCategoryName()`
- **描述**: 使用 `strcpy` 将字符串复制到固定大小的缓冲区中，没有检查源字符串长度，可能导致缓冲区溢出。

**代码片段**:
```cpp
// [IMPLANTED FLAW #5: Buffer Overflow]
// Function that copies data into a fixed-size buffer without checking bounds
void Storage::copyCategoryName(const std::string &categoryName) {
    // Fixed-size buffer
    char buffer[64];
    
    // [IMPLANTED FLAW: Buffer Overflow]
    // Using strcpy without checking if categoryName fits in buffer
    // This will overflow if categoryName.length() >= 64
    std::strcpy(buffer, categoryName.c_str());  // Buffer overflow if categoryName is too long
    
    // Use buffer (suppress unused warning)
    (void)buffer;
}
```

**触发条件**: 当调用 `Storage::copyCategoryName()` 且传入的 `categoryName` 长度 >= 64 时，会触发缓冲区溢出。

---

### 缺陷 #6: Uninitialized Variable (未初始化变量)

- **类型**: Uninitialized Variable
- **CWE**: CWE-457 (Use of Uninitialized Variable)
- **文件**: `code_cpp/src/Statistics.cpp`
- **行号**: 125-145
- **函数**: `Statistics::calculateAverage()`
- **描述**: 变量 `sum` 在使用前未被初始化，直接用于累加操作，导致未定义行为。

**代码片段**:
```cpp
// [IMPLANTED FLAW #6: Uninitialized Variable]
// Function that uses an uninitialized variable
int Statistics::calculateAverage(const std::vector<Record> &records) {
    int sum;
    // [IMPLANTED FLAW: Uninitialized Variable]
    // Variable 'sum' is used without being initialized
    // This will contain garbage value and lead to undefined behavior
    int count = static_cast<int>(records.size());
    
    for (const auto &record : records) {
        sum += static_cast<int>(record.getAmount());  // Using uninitialized 'sum'
    }
    
    if (count == 0) {
        return 0;
    }
    
    return sum / count;  // Result is undefined due to uninitialized sum
}
```

**触发条件**: 调用 `Statistics::calculateAverage()` 时会触发未初始化变量使用。

---

### 缺陷 #7: Integer Overflow (整数溢出)

- **类型**: Integer Overflow
- **CWE**: CWE-190 (Integer Overflow or Wraparound)
- **文件**: `code_cpp/src/Category.cpp`
- **行号**: 54-68
- **函数**: `Category::calculateTotalCategoryCount()`
- **描述**: 在进行整数乘法运算时，没有检查结果是否会超出整数类型的最大值，可能导致整数溢出。

**代码片段**:
```cpp
// [IMPLANTED FLAW #7: Integer Overflow]
// Function that performs arithmetic operations that can cause integer overflow
int Category::calculateTotalCategoryCount(const std::vector<Category> &categories, int multiplier) {
    int baseCount = static_cast<int>(categories.size());
    
    // [IMPLANTED FLAW: Integer Overflow]
    // Multiplying without checking for overflow
    // If baseCount * multiplier exceeds INT_MAX, this will overflow
    int total = baseCount * multiplier;  // Integer overflow possible
    
    // Further operations that can overflow
    total = total + 1000000;  // Additional overflow risk
    
    return total;
}
```

**触发条件**: 当调用 `Category::calculateTotalCategoryCount()` 且 `baseCount * multiplier` 超过 `INT_MAX` 时，会触发整数溢出。

---

### 缺陷 #8: Division by Zero (除零错误)

- **类型**: Division by Zero
- **CWE**: CWE-369 (Divide By Zero)
- **文件**: `code_cpp/src/Statistics.cpp`
- **行号**: 147-155
- **函数**: `Statistics::calculatePercentage()`
- **描述**: 在进行除法运算时，没有检查除数是否为零，当 `total` 为 0.0 时会导致除零错误。

**代码片段**:
```cpp
// [IMPLANTED FLAW #8: Division by Zero]
// Function that performs division without checking if divisor is zero
double Statistics::calculatePercentage(double value, double total) {
    // [IMPLANTED FLAW: Division by Zero]
    // Dividing by 'total' without checking if it's zero
    // This will cause a division by zero error if total == 0.0
    double percentage = (value / total) * 100.0;  // Division by zero if total == 0
    
    return percentage;
}
```

**触发条件**: 当调用 `Statistics::calculatePercentage()` 且 `total` 参数为 0.0 时，会触发除零错误。

---

### 缺陷 #9: Out of Bounds Access (越界访问)

- **类型**: Out of Bounds Access
- **CWE**: CWE-125 (Out-of-bounds Read)
- **文件**: `code_cpp/src/Search.cpp`
- **行号**: 80-103
- **函数**: `Search::processRecordArray()`
- **描述**: 访问数组元素时，使用 `count` 作为索引，但有效索引范围是 0 到 `ARRAY_SIZE-1`，当 `count >= ARRAY_SIZE` 时会越界访问。

**代码片段**:
```cpp
// [IMPLANTED FLAW #9: Out of Bounds Access]
// Function that accesses array elements without proper bounds checking
void Search::processRecordArray(const std::vector<Record> &records) {
    if (records.empty()) {
        return;
    }
    
    // Create a fixed-size array
    const int ARRAY_SIZE = 10;
    int* recordIds = new int[ARRAY_SIZE];
    
    // Copy record IDs into array
    std::size_t count = records.size();
    std::size_t copyCount = (count < ARRAY_SIZE) ? count : ARRAY_SIZE;
    
    for (std::size_t i = 0; i < copyCount; ++i) {
        recordIds[i] = static_cast<int>(i);
    }
    
    // [IMPLANTED FLAW: Out of Bounds Access]
    // Accessing array element beyond the valid range
    // If records.size() > ARRAY_SIZE, this will access out of bounds
    int value = recordIds[count];  // Out of bounds access - valid indices are 0 to ARRAY_SIZE-1
    (void)value;
    
    delete[] recordIds;
}
```

**触发条件**: 当调用 `Search::processRecordArray()` 且 `records.size() >= ARRAY_SIZE` 时，会触发越界访问。

---

## 缺陷统计

| 缺陷类型 | 数量 | CWE编号 |
|---------|------|---------|
| Memory Leak | 1 | CWE-401 |
| Double Free | 1 | CWE-415 |
| NULL Pointer Dereference | 1 | CWE-476 |
| Use After Free | 1 | CWE-416 |
| Buffer Overflow | 1 | CWE-120 |
| Uninitialized Variable | 1 | CWE-457 |
| Integer Overflow | 1 | CWE-190 |
| Division by Zero | 1 | CWE-369 |
| Out of Bounds Access | 1 | CWE-125 |
| **总计** | **9** | - |

---

## 测试建议

1. **静态分析工具测试**:
   - 使用 Cppcheck 或 Clang-Tidy 扫描项目
   - 检查是否能检测到所有九种缺陷

2. **大语言模型测试**:
   - 将相关代码片段输入 ChatGPT、通义千问等模型
   - 检查模型是否能识别这些缺陷

3. **形式化工具测试**:
   - 使用 ESBMC 等工具进行形式化验证
   - 检查是否能通过形式化方法发现这些缺陷

---

## 注意事项

⚠️ **警告**: 这些缺陷是故意植入的，仅用于实验目的。在实际开发中应避免此类缺陷。

- 缺陷 #1 会导致内存泄漏，长时间运行可能导致内存耗尽
- 缺陷 #2 会导致程序崩溃或未定义行为
- 缺陷 #3 会导致程序在特定条件下崩溃
- 缺陷 #4 会导致程序崩溃或未定义行为（释放后使用）
- 缺陷 #5 会导致缓冲区溢出，可能被利用进行安全攻击
- 缺陷 #6 会导致未定义行为，计算结果不可预测
- 缺陷 #7 会导致整数溢出，计算结果错误
- 缺陷 #8 会导致程序崩溃（除零错误）
- 缺陷 #9 会导致越界访问，可能读取或写入无效内存

在实际使用这些代码时，请先修复这些缺陷。


