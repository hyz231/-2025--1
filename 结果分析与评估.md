# 4. 结果分析与评估

## 4.1 误报率评估

- 从本次实验植入的九个缺陷来看（虽然数量有限，但能在一定程度上反映工具性能），**ChatGPT在检测率方面表现最佳**，成功检测到了全部9个植入缺陷，检测率达到100%，但同时也产生了4个误报。ChatGPT属于"风浪越大鱼越大"的类型，需要仔细甄别其输出结果。

- **ESBMC在误报率方面表现最优**，检测到8个真实缺陷，误报率为0%。作为形式化验证工具，ESBMC通过数学证明的方式验证缺陷，具有极高的准确性。虽然漏报了1个未初始化变量，但检测到的8个缺陷都是经过严格验证的，误报率极低。

- **Cppcheck检测出的真实缺陷数量相对较少**（4个），检测率为44.4%，但误报数量较多（10个）。Cppcheck在潜在的错误检测方面表现一般，主要检测到了双重释放、空指针解引用、内存泄漏和未初始化变量，但在缓冲区溢出、释放后使用、整数溢出、除零错误和越界访问方面存在漏报。误报主要集中在代码风格和规范建议上，如返回值引用、STL算法使用建议等。

## 4.2 误报原因分析

- **从代码复杂度的角度来看**，本次分析的代码规模适中，业务逻辑分布在多个文件中（Storage.cpp、Search.cpp、Statistics.cpp、User.cpp、Category.cpp等），代码量约1000行左右。对于Cppcheck这种静态分析工具，以及ChatGPT这种需要详细上下文的工具，在没有完整上下文的情况下，表现情况可能不尽如人意。例如，某些跨文件的函数调用和依赖关系，静态分析工具可能无法完全追踪，容易造成误报或漏报。

- **Cppcheck是一个静态代码分析工具**，它主要专注于发现潜在的编程错误、代码风格问题。然而，关于内存管理的错误检测，Cppcheck并不是专门针对内存泄漏、越界访问、空指针等问题进行深度分析的工具。它的设计理念更侧重于检测逻辑错误（诸如潜在的空指针解引用、无效的循环、未使用的变量等）、代码风格规范、简单的内存管理等，所以在内存方面的缺陷检测不尽如人意。但是，它能发现一些代码风格和规范问题，让人不得不感慨C++标准委员会制定的建议的合理性。例如，Cppcheck检测到的`returnByReference`、`useStlAlgorithm`等建议，虽然不会造成运行错误，但确实符合C++最佳实践。

- **ChatGPT的表现**，很大程度上是受到上下文信息以及使用习惯影响的，所以如果代码片段没有给足或者要求不清晰，就很容易出错。就比如这次实验，虽然给了它包含缺陷的代码文件，但ChatGPT为了可维护性和全面性，很可能会提出一些预防建议，而这些在你的代码中是不会对程序运行造成影响的，一定程度上也会造成误报。例如，ChatGPT报告了一些未使用的函数和变量，这些虽然确实存在，但更多是代码清理的建议，而非实际的安全问题。另外，ChatGPT有时会给出一些过于保守的建议，在某些情况下会误判一些正常的代码模式为潜在问题。

- **ESBMC作为形式化验证工具**，其误报率极低，这是因为它基于数学证明的方式验证缺陷。然而，ESBMC也存在一些局限性。首先，它对现代C++标准库的支持有限，直接对完整项目进行验证时，可能会遇到解析错误。其次，ESBMC需要将代码转换为可验证的形式，对于某些复杂的代码模式，可能需要编写最小化测试用例。例如，本次实验中未初始化变量的漏报，可能是因为在最小化用例中，ESBMC的前端分析未能捕获到该变量的使用路径，或者该变量的使用模式在形式化验证的约束求解中未能触发相应的警告。

## 5. 结论

### 5.1 各工具检测能力对比

| 工具 | 检测率 | 误报率 | 优势 | 劣势 |
|------|--------|--------|------|------|
| Cppcheck | 44.4% (4/9) | 高 (10个误报) | 易用、跨平台、代码风格检查 | 内存管理检测能力有限、误报较多 |
| ChatGPT | 100% (9/9) | 中等 (4个误报) | 语义理解强、检测全面、提供修复建议 | 需要人工甄别、上下文依赖性强 |
| ESBMC | 88.9% (8/9) | 极低 (0个误报) | 数学证明、误报率低、精确验证 | 对现代C++支持有限、需要最小化用例 |

### 5.2 工具使用建议

- **Cppcheck是一款跨平台的静态分析工具**，专注于发现潜在的错误。然而，它在内存管理方面的检测能力并不如一些专门的工具（比如ESBMC）。Cppcheck更适合用于发现不容易察觉的潜在问题，例如简单的逻辑和内存错误。建议将其与ChatGPT和ESBMC配合使用，特别是在内存相关的问题上，增强其检测能力。除此以外，大语言模型还可以补充其在复杂逻辑错误和代码重构方面的不足。

- **ChatGPT在代码分析方面表现优异**，只要给足它上下文和自己关心的点，在代码处理这部分，表现的很多时候是要比自己强的。唯一造成困扰的就是，如何能把信息准确传达给它（比如语言表达稍显情绪化或者是代码规模比较大），但就单论这次实验，在仔细甄别回答的前提下，表现是比另外两个静态分析工具要好的，而且上手难度较低。建议在开发后期使用，与Cppcheck配合使用，能够在基础静态分析的基础上提供更为深入的逻辑分析和设计优化建议，提升整体缺陷检测的能力。

- **ESBMC作为形式化验证工具**，在能解析代码或基于最小化用例时能给出精确反例与"证明"，适合关键模块的深度验证，但工程化门槛高。对于内存安全、越界访问和算术溢出类缺陷，形式化方法（ESBMC）提供最具说服力的证据；但受限于源码前端能力，需要额外工作以便对完整工程应用形式化验证。建议在发布前对关键模块使用ESBMC进行验证，特别是涉及内存管理和安全关键路径的代码。

### 5.3 工具组合推荐

- 单单从本次实验来看，个人还是比较推荐**Cppcheck + ChatGPT + ESBMC**的组合。一方面是这个组合的合理性，Cppcheck提供基础的静态分析，简单的逻辑内存错误等；ChatGPT进一步深入代码的语义层面，提供更详细的逻辑缺陷分析，内存相关方面的问题和代码重构方面的不足；ESBMC在关键模块上提供形式化验证，确保高安全性要求的代码段没有缺陷。

- 另一方面，这个组合能够互补各自的不足：Cppcheck虽然检测率不高，但能发现一些代码风格问题；ChatGPT虽然误报率较高，但检测率也高，对于内存管理的能力着实是比Cppcheck好不少；ESBMC虽然使用门槛高，但误报率极低，能够提供数学证明级别的验证。三者结合使用，能够在不同阶段和不同需求下提供全面的代码质量保障。

- 具体使用建议：
  - **开发阶段**：使用Cppcheck进行日常代码质量检查，快速发现代码风格和简单错误。
  - **代码评审阶段**：使用ChatGPT进行语义层面的深度分析，识别复杂的内存管理和逻辑问题。
  - **发布前验证**：对安全关键模块使用ESBMC进行形式化验证，确保关键代码段没有缺陷。





